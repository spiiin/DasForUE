// this file is generated via daScript automatic C++ binder
// all user modifications will be lost after this file is re-generated

template <> struct cast_arg<FString> {
	static __forceinline const FString & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FString *>::to(res);
	}
};
template <> struct cast_arg<FTextRange> {
	static __forceinline const FTextRange & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FTextRange *>::to(res);
	}
};
template <> struct cast_arg<FVTableHelper> {
	static __forceinline const FVTableHelper & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FVTableHelper *>::to(res);
	}
};
template <> struct cast_arg<FRestoreForUObjectOverwrite> {
	static __forceinline const FRestoreForUObjectOverwrite & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FRestoreForUObjectOverwrite *>::to(res);
	}
};
template <> struct cast_arg<UObjectBase> {
	static __forceinline const UObjectBase & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<UObjectBase *>::to(res);
	}
};
template <> struct cast_arg<UObjectBaseUtility> {
	static __forceinline const UObjectBaseUtility & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<UObjectBaseUtility *>::to(res);
	}
};
template <> struct cast_arg<UObject::FAssetRegistryTagMetadata> {
	static __forceinline const UObject::FAssetRegistryTagMetadata & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<UObject::FAssetRegistryTagMetadata *>::to(res);
	}
};
template <> struct cast_arg<UObject> {
	static __forceinline const UObject & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<UObject *>::to(res);
	}
};
template <> struct cast_arg<FObjectNetPushIdHelper> {
	static __forceinline const FObjectNetPushIdHelper & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FObjectNetPushIdHelper *>::to(res);
	}
};
template <> struct cast_arg<UField> {
	static __forceinline const UField & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<UField *>::to(res);
	}
};
template <> struct cast_arg<UStruct> {
	static __forceinline const UStruct & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<UStruct *>::to(res);
	}
};
template <> struct cast_arg<UEnum> {
	static __forceinline const UEnum & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<UEnum *>::to(res);
	}
};
template <> struct cast_arg<FCppClassTypeTraitsBase> {
	static __forceinline const FCppClassTypeTraitsBase & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FCppClassTypeTraitsBase *>::to(res);
	}
};
template <> struct cast_arg<ICppClassTypeInfo> {
	static __forceinline const ICppClassTypeInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<ICppClassTypeInfo *>::to(res);
	}
};
template <> struct cast_arg<FCppClassTypeInfoStatic> {
	static __forceinline const FCppClassTypeInfoStatic & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FCppClassTypeInfoStatic *>::to(res);
	}
};
template <> struct cast_arg<FCppClassTypeInfo> {
	static __forceinline const FCppClassTypeInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FCppClassTypeInfo *>::to(res);
	}
};
template <> struct cast_arg<FImplementedInterface> {
	static __forceinline const FImplementedInterface & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FImplementedInterface *>::to(res);
	}
};
template <> struct cast_arg<FNativeFunctionLookup> {
	static __forceinline const FNativeFunctionLookup & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FNativeFunctionLookup *>::to(res);
	}
};
template <> struct cast_arg<FClassFunctionLinkInfo> {
	static __forceinline const FClassFunctionLinkInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FClassFunctionLinkInfo *>::to(res);
	}
};
template <> struct cast_arg<UClass> {
	static __forceinline const UClass & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<UClass *>::to(res);
	}
};
template <> struct cast_arg<FTestUninitializedScriptStructMembersTest> {
	static __forceinline const FTestUninitializedScriptStructMembersTest & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<FTestUninitializedScriptStructMembersTest *>::to(res);
	}
};
